<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stream Monitor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>



<body class="bg-gray-100 min-h-screen text-[1.25rem] md:text-[1.5rem] leading-relaxed">
    <!-- ASCII Art Header -->
    <div class="ascii-art text-center py-6">
        <pre class="text-2xl md:text-3xl font-mono text-gray-700 overflow-auto">
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â•‘
â•‘  â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•  â•‘
â•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â•‘
â•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘     â•‘
â•‘     â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘     â•‘
â•‘     â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•     â•šâ•â•â•šâ•â•    â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•    â•šâ•â•     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        </pre>
    </div>

    <!-- Main Flex Container -->
    <div class="flex flex-col md:flex-row gap-6 px-6 pb-12 w-[75%] mx-auto">
        <!-- Left: Video Feed -->
        <div class="flex-[2] bg-white rounded shadow p-6">
            <img src="{{ url_for('video_feed') }}" alt="Video Stream" class="w-full h-auto rounded">
            <div class="mt-4 text-center">
                <p class="text-xl">Stream: <span id="stream_status">{{ stream_status }}</span></p>
                <p class="text-lg text-gray-600">Last Frame: <span id="last_frame_time">{{ last_frame_time }}</span></p>
            </div>
        </div>

        <!-- Right: Metrics on top, Chart below -->
        <div class="flex-[1] flex flex-col gap-6">
            <!-- Metrics -->
            <div class="bg-green-100 rounded shadow p-6">
                <h2 class="text-2xl font-semibold mb-4 text-center">ğŸ“ˆ Real-Time Metrics</h2>
                <div id="metrics-display" class="grid grid-cols-2 gap-x-6 gap-y-3 text-lg text-gray-800">
                    <p><strong>People Detected Today:</strong> <span id="people_detected_today">-</span></p>
                    <p><strong>Falls (Box):</strong> <span id="falls_box">-</span></p>
                    <p><strong>Falls (Pose):</strong> <span id="falls_pose">-</span></p>
                    <p><strong>Falls (Bottom):</strong> <span id="falls_bottom">-</span></p>
                    <p><strong>Falls (Full):</strong> <span id="falls_full">-</span></p>
                    <p><strong>Frames Processed:</strong> <span id="frames_processed">-</span></p>
                    <p><strong>Smells Detected Today:</strong> <span id="record_triggers_today">-</span></p>
                    <p><strong>Total Smells:</strong> <span id="total_csv_rows">-</span></p>
                </div>
            </div>

            <!-- Sensor Chart -->
            <div class="bg-blue-100 rounded shadow p-6 h-full flex flex-col">
                <h2 class="text-2xl font-semibold text-center">Sensor Data</h2>
                <p class="text-lg text-gray-600 text-center mb-4">Timestamp: <span id="sensor_timestamp">-</span></p>
                <div class="flex-grow overflow-hidden">
                    <canvas id="sensorChart" class="w-full h-full"></canvas>
                </div>
            </div>

        </div>
    </div>

    <!-- Recording Buttons -->
    <div class="w-full flex justify-center mb-12">
        <div class="bg-white p-6 rounded shadow text-center">
            <button id="start-recording"
                class="bg-green-500 text-white text-xl px-6 py-3 rounded mr-4 hover:bg-green-600">
                Start Recording
            </button>
            <button id="stop-recording" class="bg-red-500 text-white text-xl px-6 py-3 rounded hover:bg-red-600">
                Stop Recording
            </button>
            <p id="recording-status" class="mt-4 text-lg text-gray-700">Not recording.</p>
        </div>
    </div>
</body>



<!-- JavaScript -->
<script>
    let sensorChart;
    const windowSize = 5;
    const sensorHistory = [];
    const sensorDataLength = 66;
    let baseline = null;
    const sensitivityFactor = 10;  // <-- Adjust sensitivity here

    function computeBaseline(history) {
        const baseline = Array(sensorDataLength).fill(0);
        history.forEach(frame => {
            frame.forEach((val, i) => baseline[i] += val);
        });
        return baseline.map(val => val / history.length);
    }

    function normalizeUsingWindow(newFrame) {
        if (sensorHistory.length >= windowSize) {
            sensorHistory.shift();
        }
        sensorHistory.push(newFrame);

        if (sensorHistory.length < windowSize) {
            // not enough data yet
            return Array(sensorDataLength).fill(0);
        }

        if (!baseline) {
            baseline = computeBaseline(sensorHistory);
        }

        return newFrame.map((val, i) => {
            if (baseline[i] === 0) return 0;
            let normalizedVal = (val - baseline[i]) / baseline[i];
            normalizedVal *= sensitivityFactor; // scale for visibility
            normalizedVal = Math.max(-1, Math.min(normalizedVal, 1)); // clamp between [-1, 1]
            return normalizedVal;
        });
    }

    function updateStatus() {
        fetch('/status')
            .then(response => response.json())
            .then(data => {
                document.getElementById('stream_status').innerText = data.stream_status;
                document.getElementById('last_frame_time').innerText = data.last_frame_time;
            })
            .catch(error => console.error('Error fetching status:', error));
    }

    function createOrUpdateChart(values) {
        const ctx = document.getElementById('sensorChart').getContext('2d');
        const labels = values.map((_, i) => `#${i + 1}`);

        const data = {
            labels: labels,
            datasets: [{
                label: 'Sensor Variations',
                data: values,
                backgroundColor: values.map(v => v >= 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'),
                borderColor: values.map(v => v >= 0 ? 'rgba(34, 197, 94, 1)' : 'rgba(239, 68, 68, 1)'),
                borderWidth: 1
            }]
        };

        const config = {
            type: 'bar',
            data: data,
            options: {
                indexAxis: 'y',
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        min: -1,
                        max: 1,
                        ticks: {
                            stepSize: 0.1,
                            callback: (val) => `${(val * 100).toFixed(0)}%`
                        },
                        grid: {
                            drawBorder: true,
                            color: (ctx) => ctx.tick.value === 0 ? '#000' : '#e5e7eb'
                        }
                    },
                    y: {
                        ticks: {
                            autoSkip: false,
                            maxRotation: 0,
                            minRotation: 0
                        }
                    }
                },
                plugins: {
                    legend: { display: false }
                },
                elements: {
                    bar: {
                        barThickness: 'flex',
                        categoryPercentage: 0.9,
                        barPercentage: 0.9
                    }
                }
            }
        };

        if (sensorChart) {
            sensorChart.options.animation = false;
            sensorChart.data = data;
            sensorChart.update();
        } else {
            sensorChart = new Chart(ctx, config);
        }
    }


    function updateSensorData() {
        fetch('/get-latest-sensor-data')
            .then(response => response.json())
            .then(data => {
                document.getElementById('sensor_timestamp').innerText = data.timestamp || "-";
                if (data.data && Array.isArray(data.data)) {
                    const cleanedValues = data.data.map(v => parseFloat(v)).filter(v => !isNaN(v));

                    console.log("Cleaned Values Length:", cleanedValues.length, cleanedValues);


                    if (cleanedValues.length === sensorDataLength) {
                        const normalized = normalizeUsingWindow(cleanedValues);
                        createOrUpdateChart(normalized);
                    }
                }

            })
            .catch(error => console.error('Error fetching sensor data:', error));
    }

    function updateMetrics() {
        fetch('/metrics')
            .then(response => response.json())
            .then(data => {
                document.getElementById('people_detected_today').innerText = data.people_detected_today;
                document.getElementById('falls_box').innerText = data.falls_box;
                document.getElementById('falls_pose').innerText = data.falls_pose;
                document.getElementById('falls_bottom').innerText = data.falls_bottom;
                document.getElementById('falls_full').innerText = data.falls_full;
                document.getElementById('frames_processed').innerText = data.frames_processed;
                document.getElementById('record_triggers_today').innerText = data.record_triggers_today;
                document.getElementById('total_csv_rows').innerText = data.total_csv_rows;
            })
            .catch(error => console.error('Error fetching metrics:', error));
    }


    document.getElementById('start-recording').onclick = () => {
        fetch('/start-recording', { method: 'POST' })
            .then(res => res.json())
            .then(data => {
                document.getElementById('recording-status').innerText = data.status;
            })
            .catch(e => console.error(e));
    };

    document.getElementById('stop-recording').onclick = () => {
        fetch('/stop-recording', { method: 'POST' })
            .then(res => res.json())
            .then(data => {
                document.getElementById('recording-status').innerText = data.status;
            })
            .catch(e => console.error(e));
    };

    setInterval(updateStatus, 1000);
    setInterval(updateSensorData, 1000);
    setInterval(updateMetrics, 1000);

    updateMetrics();
    updateStatus();
    updateSensorData();
</script>
</body>

</html>