<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stream Monitor Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        html, body {
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .dashboard-container {
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr;
            background: rgb(30, 64, 175);
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 0 1rem 1rem 1rem;
            height: 100%;
            overflow: hidden;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            height: 100%;
            overflow: hidden;
        }

        .video-section {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .video-container {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f3f4f6;
            border-radius: 0.5rem;
            overflow: hidden;
        }

        .video-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .map-section {
            height: 45%;
            min-height: 0;
        }

        .metrics-section {
            height: 10%;
            min-height: 0;
            overflow-y: auto;
        }

        .chart-section {
            height: 45%;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .chart-container {
            flex: 1;
            min-height: 0;
            position: relative;
        }

        .ascii-header {
            padding: 0.5rem;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .ascii-header pre {
            font-size: clamp(0.5rem, 3vw, 2rem);
            line-height: 1;
            margin: 0;
        }

        .panel-box {
            background: #f3f4f6;
            border: 2px solid rgb(30, 64, 175);
            border-radius: 0.5rem;
            padding: 0.75rem;
            /*height: 100%;*/
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            justify-content: center;
            padding: 0.5rem;
        }

        .control-button {
            padding: 0.5rem 1rem;
            border-radius: 0.25rem;
            color: white;
            font-size: clamp(1rem, 2vw, 1.5rem);
            white-space: nowrap;
            transition: all 0.2s;
        }

        .status-text {
            font-size: clamp(1.25rem, 2.5vw, 2rem);
            margin: 0.25rem 0;
        }

        .metric-item {
            font-size: clamp(0.875rem, 1.75vw, 1.25rem);
            margin: 0.1rem 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .section-title {
            font-size: clamp(1.25rem, 2.5vw, 2rem);
            font-weight: bold;
            margin-bottom: 0.25rem;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr;
            }

            .ascii-header pre {
                font-size: 0.6rem;
            }

            .metrics-section {
                height: 20%;
            }
        }

        @media (max-height: 600px) {
            .map-section { height: 45%; }
            .metrics-section { height: 10%; }
        }

        /* For very large screens (TVs) */
        @media (min-width: 1920px) {
            .status-text {
                font-size: clamp(2rem, 3vw, 3rem);
            }

            .metric-item {
                font-size: clamp(1.5rem, 2vw, 2rem);
            }

            .section-title {
                font-size: clamp(2rem, 3vw, 3rem);
            }

            .control-button {
                font-size: clamp(1.5rem, 2.5vw, 2.5rem);
                padding: 0.75rem 1.5rem;
            }

            .ascii-header pre {
                font-size: clamp(1.5rem, 4vw, 3rem);
            }
            .legend-item {
                font-size: clamp(1.5rem, 2.5vw, 2rem);
            }
        }

        .map-container-wrapper {
            position: relative;
            width: 100%;
            height: calc(100% - 3rem);
            overflow: hidden;
        }

        .map-legend {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 0.5rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: clamp(0.875rem, 1.75vw, 1.25rem);
        }

        .legend-dot {
            width: clamp(12px, 1.5vw, 20px);
            height: clamp(12px, 1.5vw, 20px);
            border-radius: 50%;
            border: 1px solid white;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            font-size: clamp(0.875rem, 1.75vw, 1.25rem);
        }

        .timestamp-text {
            font-size: clamp(0.875rem, 1.5vw, 1.25rem);
        }
    </style>
</head>

<body>
    <div class="dashboard-container">
        <!-- ASCII Art Header -->
        <div class="ascii-header text-center">
            <pre class="font-mono text-gray-100">
╔══════════════════════════════════════════════════════════════════════════════════╗
║  ████████╗███████╗███╗   ███╗██╗    ██████╗  ██████╗ ██████╗  ██████╗ ████████╗  ║
║  ╚══██╔══╝██╔════╝████╗ ████║██║    ██╔══██╗██╔═══██╗██╔══██╗██╔═══██╗╚══██╔══╝  ║
║     ██║   █████╗  ██╔████╔██║██║    ██████╔╝██║   ██║██████╔╝██║   ██║   ██║     ║
║     ██║   ██╔══╝  ██║╚██╔╝██║██║    ██╔══██╗██║   ██║██╔══██╗██║   ██║   ██║     ║
║     ██║   ███████╗██║ ╚═╝ ██║██║    ██║  ██║╚██████╔╝██████╔╝╚██████╔╝   ██║     ║
║     ╚═╝   ╚══════╝╚═╝     ╚═╝╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═════╝  ╚═════╝    ╚═╝     ║
╚══════════════════════════════════════════════════════════════════════════════════╝
            </pre>
        </div>

        <!-- Main Content Grid -->
        <div class="main-content">
            <!-- Left Panel -->
            <div class="left-panel">
                <div class="video-section panel-box">
                    <div class="video-container">
                        <img src="{{ url_for('video_feed') }}" alt="Video Stream">
                    </div>
                    <div class="text-center mt-2">
                        <p class="status-text">Stream: <span id="stream_status" class="font-bold">{{ stream_status }}</span></p>
                        <p class="status-text">Recording: <span id="recording-status" class="font-bold">Not Recording</span></p>
                        <p class="status-text text-gray-600">Last Frame: <span id="last_frame_time">{{ last_frame_time }}</span></p>
                    </div>
                    <div class="button-group">
                        <button id="start-recording" class="control-button bg-green-500 hover:bg-green-600">Start Recording</button>
                        <button id="stop-recording" class="control-button bg-red-500 hover:bg-red-600">Stop Recording</button>
                        <button id="toggle-mode" class="control-button bg-blue-500 hover:bg-blue-600">Glasses</button>
                        <button id="toggle-fullscreen" class="control-button bg-purple-500 hover:bg-purple-600">Fullscreen</button>
                    </div>
                </div>
            </div>

            <!-- Right Panel -->
            <div class="right-panel">
                <!-- Map Section -->
                <div class="map-section panel-box">
                    <h2 class="section-title text-center">Temi's Location</h2>
                    <div class="map-container-wrapper">
                        <div id="map-container" style="position: relative; width: 100%; height: 100%;">
                            <img id="map-image" src="../static/map.png" alt="Temi Robot Map"
                                 style="width: 100%; height: 100%; object-fit: fill;">
                            <div id="classification-dots-container"
                                 style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                            <div id="robot-dot"
                                 style="position: absolute; width: 20px; height: 20px; background-color: darkblue;
                                        border-radius: 50%; transform: translate(-50%, -50%); display: none;"></div>
                        </div>
                    </div>
                    <div class="map-legend">
                        <div class="legend-item">
                            <span class="legend-dot" style="background-color: darkblue;"></span>
                            <span>Current Position</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-dot" style="background-color: #dc2626;"></span>
                            <span>Ammonia</span>
                        </div>
                        <div class="legend-item">
                            <span class="legend-dot" style="background-color: #16a34a;"></span>
                            <span>No Ammonia</span>
                        </div>
                    </div>
                </div>

                <!-- Metrics Section - Made more compact -->
                <div class="metrics-section panel-box">
                    <h2 class="section-title text-center">📈 Metrics</h2>
                    <div id="metrics-display" class="metrics-grid">
                        <p class="metric-item"><strong>People:</strong> <span id="people_detected_today">-</span></p>
                        <p class="metric-item"><strong>Box:</strong> <span id="falls_box">-</span></p>
                        <p class="metric-item"><strong>Pose:</strong> <span id="falls_pose">-</span></p>
                        <p class="metric-item"><strong>Bottom:</strong> <span id="falls_bottom">-</span></p>
                        <p class="metric-item"><strong>Full:</strong> <span id="falls_full">-</span></p>
                        <p class="metric-item"><strong>Frames:</strong> <span id="frames_processed">-</span></p>
                        <p class="metric-item"><strong>Smells:</strong> <span id="new_csv_rows_today">-</span></p>
                        <p class="metric-item"><strong>Total:</strong> <span id="total_csv_rows">-</span></p>
                    </div>
                </div>

                <!-- Chart Section - Gets more space now -->
                <div class="chart-section panel-box">
                    <h2 class="section-title text-center">Smell Data (2 Hours)</h2>
                    <p class="text-center text-gray-600 timestamp-text">
                        Timestamp: <span id="sensor_timestamp">-</span>
                    </p>
                    <div class="chart-container">
                        <canvas id="sensorChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    // --- GLOBAL STATE ---
    let sensorChart;
    const twoHourWindow = 2 * 60 * 60 * 1000;
    let glassesMode = false;
    let fullscreenMode = false;
    let recording = false;
    let toggleTimeout;
    let fullscreenTimeout;

    // --- CHART AND MAP LOGIC ---
    function createOrUpdateChart() {
        if (sensorChart) return;

        const ctx = document.getElementById('sensorChart').getContext('2d');
        const lineColors = ['#FF6384', '#36A2EB', '#FFCE56', '#08d5bd', '#9966FF', '#FF9F40',
                           '#8C564B', '#E83E8C', '#20C997', '#6610F2', '#fd9814', '#17A2B8',
                           '#6F42C1', '#DC3545', '#c242f0', '#0072B2', '#D55E00'];

        const datasets = Array.from({ length: 17 }, (_, i) => {
            let label = i < 15 ? `S${i + 1}` : (i === 15 ? 'Temp' : 'Humid');
            return {
                label: label,
                data: [],
                borderColor: lineColors[i],
                backgroundColor: lineColors[i],
                fill: false,
                borderWidth: 1,
                pointRadius: 0,
            };
        });

        // Determine font sizes based on screen size
        const isLargeScreen = window.innerWidth >= 1920;
        const titleSize = isLargeScreen ? 20 : 14;
        const labelSize = isLargeScreen ? 16 : 11;
        const tickSize = isLargeScreen ? 14 : 10;

        sensorChart = new Chart(ctx, {
            type: 'line',
            data: { datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'HH:mm:ss',
                            displayFormats: { minute: 'HH:mm' }
                        },
                        title: {
                            display: true,
                            text: 'Time',
                            font: { size: titleSize }
                        },
                        ticks: { font: { size: tickSize } }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Value',
                            font: { size: titleSize }
                        },
                        ticks: { font: { size: tickSize } }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            font: { size: labelSize },
                            boxWidth: isLargeScreen ? 15 : 10,
                            padding: isLargeScreen ? 10 : 5
                        }
                    },
                    title: {
                        display: false
                    }
                }
            }
        });
    }

    function addDataToChart(timestamp, values) {
        if (!sensorChart || !values || values.length !== 17) return;

        const newTime = new Date(timestamp).getTime();
        values.forEach((value, i) => {
            sensorChart.data.datasets[i].data.push({ x: newTime, y: value });
        });

        sensorChart.data.datasets.forEach(dataset => {
            while (dataset.data.length > 0 && newTime - dataset.data[0].x > twoHourWindow) {
                dataset.data.shift();
            }
        });
        sensorChart.update('none');
    }

    function plotClassificationDot(x_pos, y_pos, classification) {
        const mapContainer = document.getElementById('classification-dots-container');
        const mapImage = document.getElementById('map-image');
        if (!mapContainer || !mapImage || mapImage.clientWidth === 0) return;

        const dot = document.createElement('div');
        const dotSize = window.innerWidth >= 1920 ? '15px' : '10px';
        dot.style.cssText = `position: absolute; width: ${dotSize}; height: ${dotSize}; border-radius: 50%;
                             border: 1px solid white; transform: translate(-50%, -50%);`;
        dot.style.backgroundColor = classification === 'ambient' ? '#16a34a' : '#dc2626';

        const { scaleX, scaleY, top, left } = getMapScalingFactors(mapImage);
        dot.style.left = `${left(y_pos, scaleX)}px`;
        dot.style.top = `${top(x_pos, scaleY)}px`;

        mapContainer.appendChild(dot);
    }

    function updateRobotPosition(x_pos, y_pos) {
        const robotDot = document.getElementById('robot-dot');
        const mapImage = document.getElementById('map-image');
        if (!robotDot || !mapImage || mapImage.clientWidth === 0) return;

        const dotSize = window.innerWidth >= 1920 ? '30px' : '20px';
        robotDot.style.width = dotSize;
        robotDot.style.height = dotSize;

        const { scaleX, scaleY, top, left } = getMapScalingFactors(mapImage);
        robotDot.style.left = `${left(y_pos, scaleX)}px`;
        robotDot.style.top = `${top(x_pos, scaleY)}px`;
        robotDot.style.display = 'block';
    }

    function getMapScalingFactors(mapImageElement) {
        const PY_ORIGIN_X_METERS = -12.779715, PY_ORIGIN_Y_METERS = -10.486041;
        const PY_RESOLUTION = 0.05, PY_TOP_CROP = 100, PY_LEFT_CROP = 20;
        const CROPPED_ROWS = 407, CROPPED_COLS = 1221;

        const scaleX = mapImageElement.clientWidth / CROPPED_COLS;
        const scaleY = mapImageElement.clientHeight / CROPPED_ROWS;

        const top = (x_pos, scale) => (Math.round((x_pos - PY_ORIGIN_X_METERS) / PY_RESOLUTION) - PY_TOP_CROP) * scale;
        const left = (y_pos, scale) => (Math.round((y_pos - PY_ORIGIN_Y_METERS) / PY_RESOLUTION) - PY_LEFT_CROP) * scale;

        return { scaleX, scaleY, top, left };
    }

    // --- UI AND STATE MANAGEMENT ---
    function updateButtonStates() {
        const states = {
            'start-recording': recording,
            'stop-recording': !recording,
            'toggle-mode': glassesMode,
            'toggle-fullscreen': fullscreenMode,
        };
        for (const [id, isActive] of Object.entries(states)) {
            const btn = document.getElementById(id);
            if (isActive) {
                btn.classList.add("ring-2", "ring-offset-1", "ring-gray-300", "opacity-90");
            } else {
                btn.classList.remove("ring-2", "ring-offset-1", "ring-gray-300", "opacity-90");
            }
        }
    }

    function updateMetrics(data) {
        for (const [key, value] of Object.entries(data)) {
            const el = document.getElementById(key);
            if (el) el.innerText = value ?? '-';
        }
    }

    function setVisionMode(mode) {
        return fetch('/set-vision-mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: mode })
        });
    }

    // --- MAIN EXECUTION ---
    document.addEventListener('DOMContentLoaded', () => {
        createOrUpdateChart();
        updateButtonStates();

        // Recreate chart on window resize for proper scaling
        window.addEventListener('resize', () => {
            if (sensorChart) {
                sensorChart.destroy();
                sensorChart = null;
                createOrUpdateChart();
            }
        });

        // Button event listeners
        document.getElementById('start-recording').onclick = () => {
            fetch('/start-recording', { method: 'POST' }).then(res => res.json()).then(data => {
                recording = true;
                document.getElementById('recording-status').innerText = data.status;
                updateButtonStates();
            });
        };

        document.getElementById('stop-recording').onclick = () => {
            fetch('/stop-recording', { method: 'POST' }).then(res => res.json()).then(data => {
                recording = false;
                document.getElementById('recording-status').innerText = 'Not Recording';
                updateButtonStates();
            });
        };

        document.getElementById('toggle-mode').onclick = () => {
            glassesMode = !glassesMode;
            if (glassesMode) fullscreenMode = false;
            setVisionMode(glassesMode ? 'glasses' : 'none');
            updateButtonStates();

            clearTimeout(toggleTimeout);
            if (glassesMode) {
                toggleTimeout = setTimeout(() => {
                    glassesMode = false;
                    setVisionMode('none');
                    updateButtonStates();
                }, 30000);
            }
        };

        document.getElementById('toggle-fullscreen').onclick = () => {
            fullscreenMode = !fullscreenMode;
            if (fullscreenMode) glassesMode = false;
            setVisionMode(fullscreenMode ? 'fullscreen' : 'none');
            updateButtonStates();

            clearTimeout(fullscreenTimeout);
            if (fullscreenMode) {
                fullscreenTimeout = setTimeout(() => {
                    fullscreenMode = false;
                    setVisionMode('none');
                    updateButtonStates();
                }, 60000);
            }
        };

        // Fetch initial metrics
        fetch('/metrics')
            .then(res => res.json())
            .then(updateMetrics)
            .catch(err => console.error("Failed to fetch initial metrics:", err));

        // SSE connection
        let eventSource = new EventSource('/stream-updates');
        eventSource.onopen = () => console.log('SSE connection opened.');

        eventSource.addEventListener('metrics_update', e => updateMetrics(JSON.parse(e.data)));
        eventSource.addEventListener('sensor_update', e => {
            const data = JSON.parse(e.data);
            document.getElementById('sensor_timestamp').innerText = data.timestamp || "-";
            addDataToChart(data.timestamp, data.values);
        });
        eventSource.addEventListener('map_dot_update', e => {
            const data = JSON.parse(e.data);
            plotClassificationDot(data.x, data.y, data.class);
        });
        eventSource.addEventListener('robot_position_update', e => {
            const data = JSON.parse(e.data);
            updateRobotPosition(data.x, data.y);
        });
        eventSource.addEventListener('clear_map_dots', e => {
            const dotsContainer = document.getElementById('classification-dots-container');
            if (dotsContainer) dotsContainer.innerHTML = '';
            console.log('Cleared map dots for the new day.');
        });
        eventSource.onerror = err => {
            console.error("EventSource failed:", err);
            setTimeout(() => {
                console.log("Attempting to reconnect...");
                eventSource = new EventSource('/stream-updates');
            }, 5000);
        };
    });
</script>
</body>
</html>