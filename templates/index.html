<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Stream Monitor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/date-fns@3/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
</head>
<body class="bg-blue-800 min-h-screen text-[2rem] md:text-[2.5rem] leading-relaxed flex flex-col">
    <div class="ascii-art text-center py-8">
        <pre class="text-4xl md:text-6xl font-mono text-gray-100 overflow-auto">
╔══════════════════════════════════════════════════════════════════════════════════╗
║  ████████╗███████╗███╗   ███╗██╗    ██████╗  ██████╗ ██████╗  ██████╗ ████████╗  ║
║  ╚══██╔══╝██╔════╝████╗ ████║██║    ██╔══██╗██╔═══██╗██╔══██╗██╔═══██╗╚══██╔══╝  ║
║     ██║   █████╗  ██╔████╔██║██║    ██████╔╝██║   ██║██████╔╝██║   ██║   ██║     ║
║     ██║   ██╔══╝  ██║╚██╔╝██║██║    ██╔══██╗██║   ██║██╔══██╗██║   ██║   ██║     ║
║     ██║   ███████╗██║ ╚═╝ ██║██║    ██║  ██║╚██████╔╝██████╔╝╚██████╔╝   ██║     ║
║     ╚═╝   ╚══════╝╚═╝     ╚═╝╚═╝    ╚═╝  ╚═╝ ╚═════╝ ╚═════╝  ╚═════╝    ╚═╝     ║
╚══════════════════════════════════════════════════════════════════════════════════╝
        </pre>
    </div>

    <div class="flex flex-col md:flex-row gap-8 px-8 flex-grow">
        <!-- Left Section: Video and Buttons -->
        <div class="w-full md:w-1/2 flex flex-col">
            <div class="bg-gray-100 border-2 border-blue-800 rounded shadow p-8 flex-grow">
                <img src="{{ url_for('video_feed') }}" alt="Video Stream" class="w-full h-[70vh] object-contain rounded">
                <div class="mt-6 text-center">
                    <p class="text-6xl">Stream: <span id="stream_status">{{ stream_status }}</span></p>
                    <p class="text-5xl text-gray-600">Last Frame: <span id="last_frame_time">{{ last_frame_time }}</span></p>
                </div>
                <div class="w-full flex justify-center mb-8 mt-6">
                    <div class="bg-gray-100 p-4 rounded shadow text-center">
                        <div class="flex flex-row justify-center items-center space-x-4">
                            <button id="start-recording" class="bg-green-500 text-white text-6xl px-4 py-2 rounded hover:bg-green-600">Start Recording</button>
                            <button id="stop-recording" class="bg-red-500 text-white text-6xl px-4 py-2 rounded hover:bg-red-600">Stop Recording</button>
                            <button id="toggle-mode" class="bg-blue-500 text-white text-6xl px-4 py-2 rounded shadow hover:bg-blue-600">Glasses</button>
                            <button id="toggle-fullscreen" class="bg-purple-500 text-white text-6xl px-4 py-2 rounded shadow hover:bg-purple-600">Fullscreen</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Section: Map, Metrics, and Sensor Plot -->
        <div class="w-full md:w-1/2 flex flex-col gap-8">
            <!-- Map Section -->
            <div class="bg-gray-100 border-2 border-blue-800 rounded shadow p-8">
                <h2 class="text-6xl font-semibold text-center mb-6">Temi's Location on Suite Map</h2>
                <div id="map-container" style="position: relative; width: 100%; max-width: 2400px; margin: auto;">
                    <img id="map-image" src="../static/map.png" alt="Temi Robot Map" style="width: 100%; height: auto; display: block; margin: auto;">

                    <div id="classification-dots-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>

                    <div id="robot-dot" style="position: absolute; width: 30px; height: 30px; background-color: darkblue; border-radius: 50%; transform: translate(-50%, -50%); display: none;"></div>
                </div>
                <div class="mt-4 flex justify-center items-center gap-x-6">
                    <div class="flex items-center gap-x-2">
                        <span class="h-5 w-5 rounded-full bg-blue-800 border-2 border-white"></span>
                        <p class="text-5xl text-gray-800">Temi's Current Position</p>
                    </div>
                    <div class="flex items-center gap-x-2">
                        <span class="h-5 w-5 rounded-full bg-red-600 border-2 border-white"></span>
                        <p class="text-5xl text-gray-800">Ammonia Detected</p>
                    </div>
                    <div class="flex items-center gap-x-2">
                        <span class="h-5 w-5 rounded-full bg-green-600 border-2 border-white"></span>
                        <p class="text-5xl text-gray-800">No Ammonia Detected</p>
                    </div>
                </div>
            </div>

            <!-- Metrics and Sensor Plot -->
            <div class="flex flex-col gap-8">
                <div class="bg-gray-100 border-2 border-blue-800 rounded shadow p-8">
                    <h2 class="text-6xl font-semibold mb-6 text-center">📈 Real-Time Metrics</h2>
                    <div id="metrics-display" class="grid grid-cols-4 gap-x-6 gap-y-4 text-4xl text-gray-800">
                        <p><strong>People Detected Today:</strong> <span id="people_detected_today">-</span></p>
                        <p><strong>Falls (Box):</strong> <span id="falls_box">-</span></p>
                        <p><strong>Falls (Pose):</strong> <span id="falls_pose">-</span></p>
                        <p><strong>Falls (Bottom):</strong> <span id="falls_bottom">-</span></p>
                        <p><strong>Falls (Full):</strong> <span id="falls_full">-</span></p>
                        <p><strong>Frames Processed:</strong> <span id="frames_processed">-</span></p>
                        <p><strong>Smells Detected Today:</strong> <span id="new_csv_rows_today">-</span></p>
                        <p><strong>Total Smells:</strong> <span id="total_csv_rows">-</span></p>
                    </div>
                </div>
                <div class="bg-gray-100 border-2 border-blue-800 rounded shadow p-8 flex flex-col flex-grow">
                    <h2 class="text-6xl font-semibold text-center">Last Two Hours of Smell Data</h2>
                    <p class="text-5xl text-gray-600 text-center mb-6">Timestamp: <span id="sensor_timestamp">-</span></p>
                    <div class="flex-grow overflow-hidden">
                        <canvas id="sensorChart" class="w-full h-full"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

<script>
    let sensorChart;
    const twoHourWindow = 2 * 60 * 60 * 1000; // 2 hours in milliseconds

    let glassesMode = false;
    let fullscreenMode = false;
    let recording = false;

    let toggleTimeout;
    let fullscreenTimeout;

    function updateButtonStates() {
        const btnStart = document.getElementById('start-recording');
        const btnStop = document.getElementById('stop-recording');
        const btnGlasses = document.getElementById('toggle-mode');
        const btnFullscreen = document.getElementById('toggle-fullscreen');

        [btnStart, btnStop, btnGlasses, btnFullscreen].forEach(btn =>
            btn.classList.remove("ring", "ring-offset-2", "ring-offset-white", "ring-gray-400", "opacity-90")
        );

        if (recording) {
            btnStart.classList.add("ring", "ring-offset-2", "ring-offset-white", "ring-gray-400", "opacity-90");
        } else {
            btnStop.classList.add("ring", "ring-offset-2", "ring-offset-white", "ring-gray-400", "opacity-90");
        }

        if (glassesMode) {
            btnGlasses.classList.add("ring", "ring-offset-2", "ring-offset-white", "ring-gray-400", "opacity-90");
        }

        if (fullscreenMode) {
            btnFullscreen.classList.add("ring", "ring-offset-2", "ring-offset-white", "ring-gray-400", "opacity-90");
        }
    }

    document.getElementById('start-recording').onclick = () => {
        fetch('/start-recording', { method: 'POST' })
            .then(res => res.json())
            .then(data => {
                recording = true;
                document.getElementById('recording-status').innerText = data.status;
                updateButtonStates();
            });
    };

    document.getElementById('stop-recording').onclick = () => {
        fetch('/stop-recording', { method: 'POST' })
            .then(res => res.json())
            .then(data => {
                recording = false;
                document.getElementById('recording-status').innerText = data.status;
                updateButtonStates();
            });
    };

    document.getElementById('toggle-mode').onclick = () => {
        glassesMode = !glassesMode;
        fullscreenMode = false;
        updateButtonStates();

        fetch('/set-vision-mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: glassesMode ? 'glasses' : 'none' })
        });

        if (glassesMode) {
            clearTimeout(toggleTimeout);
            toggleTimeout = setTimeout(() => {
                glassesMode = false;
                updateButtonStates();
                fetch('/set-vision-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'none' })
                });
            }, 30000);
        }
    };

    document.getElementById('toggle-fullscreen').onclick = () => {
        fullscreenMode = !fullscreenMode;
        glassesMode = false;
        updateButtonStates();

        fetch('/set-vision-mode', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mode: fullscreenMode ? 'fullscreen' : 'none' })
        });

        if (fullscreenMode) {
            clearTimeout(fullscreenTimeout);
            fullscreenTimeout = setTimeout(() => {
                fullscreenMode = false;
                updateButtonStates();
                fetch('/set-vision-mode', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'none' })
                });
            }, 60000);
        }
    };

    // --- CHART AND MAP LOGIC REBUILT FOR SSE ---

    function createOrUpdateChart() {
        if (sensorChart) return; // Only create once

        const ctx = document.getElementById('sensorChart').getContext('2d');

        // Helper to generate 17 distinct colors for the lines
        const lineColors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#08d5bd', '#9966FF', '#FF9F40', '#8C564B',
            '#E83E8C', '#20C997', '#6610F2', '#fd9814', '#17A2B8', '#6F42C1', '#DC3545',
            '#c242f0', '#0072B2', '#D55E00'
        ];

        const datasets = [];
        for (let i = 0; i < 17; i++) {
            let label;
            if (i < 15) {
                label = `Sensor Group ${i + 1}`;
            } else if (i === 15) {
                label = 'Temperature';
            } else {
                label = 'Humidity';
            }
            datasets.push({
                label: label,
                data: [], // Data points will be {x: timestamp, y: value}
                borderColor: lineColors[i],
                backgroundColor: lineColors[i],
                fill: false,
                borderWidth: 2,
                pointRadius: 1,
            });
        }

        const config = {
            type: 'line',
            data: {
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'll HH:mm:ss',
                            displayFormats: {
                                minute: 'HH:mm'
                            }
                        },
                        title: {
                            display: true,
                            text: 'Timestamp'
                            font: {
                                size: 18
                            }
                        },
                        ticks: {
                            font: {
                                size: 14
                            }
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Sensor Value',
                            font: {
                                size: 18
                            }
                        },
                        ticks: {
                            font: {
                                 size: 14
                            }
                        }
                    }
    },
    plugins: {
        legend: {
            position: 'top',
            labels: {
                font: {
                    size: 16
                }
            }
        },
        title: {
            display: true,
            text: 'Live Sensor Readings (2-Hour Window)',
            font: {
                size: 20
            }
        }
    }
            }
        };

        sensorChart = new Chart(ctx, config);
    }

    function addDataToChart(timestamp, values) {
        if (!sensorChart || values.length !== 17) return;

        const newTime = new Date(timestamp).getTime();

        // Add new data
        values.forEach((value, i) => {
            sensorChart.data.datasets[i].data.push({ x: newTime, y: value });
        });

        // Remove old data that is outside the 2-hour window
        sensorChart.data.datasets.forEach(dataset => {
            while (dataset.data.length > 0 && newTime - dataset.data[0].x > twoHourWindow) {
                dataset.data.shift();
            }
        });

        sensorChart.update();
    }

    function plotClassificationDot(x_pos, y_pos, classification) {
        // This function places a PERMANENT dot for a classification event
        const mapContainer = document.getElementById('classification-dots-container');
        if (!mapContainer) return;

        const dot = document.createElement('div');
        dot.style.position = 'absolute';
        dot.style.width = '15px';
        dot.style.height = '15px';
        dot.style.borderRadius = '50%';
        dot.style.border = '2px solid white';
        dot.style.backgroundColor = classification === 'ambient' ? 'darkgreen' : 'red';

        // We need to use the same scaling logic as the moving robot dot
        const mapImageElement = document.getElementById('map-image');
        if (!mapImageElement || mapImageElement.clientWidth === 0) return;

        const imageDisplayWidthPx = mapImageElement.clientWidth;
        const imageDisplayHeightPx = mapImageElement.clientHeight;

        const PY_ORIGIN_X_METERS = -12.779715;
        const PY_ORIGIN_Y_METERS = -10.486041;
        const PY_RESOLUTION_METERS_PER_PIXEL = 0.05;
        const PY_TOP_CROP_PIXELS = 100;
        const PY_LEFT_CROP_PIXELS = 20;
        const CROPPED_ROWS = 407;
        const CROPPED_COLS = 1221;

        let i_px = Math.round((x_pos - PY_ORIGIN_X_METERS) / PY_RESOLUTION_METERS_PER_PIXEL) - PY_TOP_CROP_PIXELS;
        let j_px = Math.round((y_pos - PY_ORIGIN_Y_METERS) / PY_RESOLUTION_METERS_PER_PIXEL) - PY_LEFT_CROP_PIXELS;

        const scaleX = imageDisplayWidthPx / CROPPED_COLS;
        const scaleY = imageDisplayHeightPx / CROPPED_ROWS;

        dot.style.left = `${j_px * scaleX}px`;
        dot.style.top = `${i_px * scaleY}px`;
        dot.style.transform = 'translate(-50%, -50%)';

        mapContainer.appendChild(dot);
    }

    function updateRobotPosition(x_pos, y_pos) {
        // This function MOVES the main robot dot
        const robotDotElement = document.getElementById('robot-dot');
        const mapImageElement = document.getElementById('map-image');
        if (!robotDotElement || !mapImageElement || mapImageElement.clientWidth === 0) return;

        const imageDisplayWidthPx = mapImageElement.clientWidth;
        const imageDisplayHeightPx = mapImageElement.clientHeight;
        const PY_ORIGIN_X_METERS = -12.779715;
        const PY_ORIGIN_Y_METERS = -10.486041;
        const PY_RESOLUTION_METERS_PER_PIXEL = 0.05;
        const PY_TOP_CROP_PIXELS = 100;
        const PY_LEFT_CROP_PIXELS = 20;
        const CROPPED_ROWS = 407;
        const CROPPED_COLS = 1221;

        let i_px = Math.round((x_pos - PY_ORIGIN_X_METERS) / PY_RESOLUTION_METERS_PER_PIXEL) - PY_TOP_CROP_PIXELS;
        let j_px = Math.round((y_pos - PY_ORIGIN_Y_METERS) / PY_RESOLUTION_METERS_PER_PIXEL) - PY_LEFT_CROP_PIXELS;

        const scaleX = imageDisplayWidthPx / CROPPED_COLS;
        const scaleY = imageDisplayHeightPx / CROPPED_ROWS;

        robotDotElement.style.left = `${j_px * scaleX}px`;
        robotDotElement.style.top = `${i_px * scaleY}px`;
        robotDotElement.style.display = 'block';
    }


    // --- SSE CHANGE: Main Event Listener ---
    const eventSource = new EventSource('/stream-updates');

    eventSource.addEventListener('sensor_update', function(event) {
        const data = JSON.parse(event.data);
        document.getElementById('sensor_timestamp').innerText = data.timestamp || "-";
        addDataToChart(data.timestamp, data.values);
    });

    eventSource.addEventListener('map_dot_update', function(event) {
        const data = JSON.parse(event.data);
        plotClassificationDot(data.x, data.y, data.class);
    });

    eventSource.addEventListener('robot_position_update', function(event) {
        const data = JSON.parse(event.data);
        updateRobotPosition(data.x, data.y);
    });

    eventSource.addEventListener('clear_map_dots', function(event) {
        console.log('Received signal to clear map dots.', event.data);
        const dotsContainer = document.getElementById('classification-dots-container');
        if (dotsContainer) {
            dotsContainer.innerHTML = ''; // Clear all the red and green dots
        }
    });

    eventSource.addEventListener('metrics_update', function(event) {
        const data = JSON.parse(event.data);
        document.getElementById('people_detected_today').innerText = data.people_detected_today;
        document.getElementById('falls_box').innerText = data.falls_box;
        document.getElementById('falls_pose').innerText = data.falls_pose;
        document.getElementById('falls_bottom').innerText = data.falls_bottom;
        document.getElementById('falls_full').innerText = data.falls_full;
        document.getElementById('frames_processed').innerText = data.frames_processed;
        document.getElementById('new_csv_rows_today').innerText = data.new_csv_rows_today;
        document.getElementById('total_csv_rows').innerText = data.total_csv_rows;
    });

    eventSource.onerror = function(err) {
        console.error("EventSource failed:", err);
    };

    // Initial setup calls
    createOrUpdateChart();
    updateButtonStates();
    // We can fetch initial metrics once on load
    fetch('/metrics').then(res => res.json()).then(data => {
        // This is the same logic as the metrics_update event
        document.getElementById('people_detected_today').innerText = data.people_detected_today;
        document.getElementById('falls_box').innerText = data.falls_box;
        // ... and so on for all metrics
    });

</script>
</body>
</html>
